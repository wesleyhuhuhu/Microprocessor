# load preamble length to reg6
IMM reg6 61
# load mem[61] (preamble length) to reg6
LDR reg6 reg6
# load LFSR starting state to reg5
IMM reg5 63
# load mem[63] (LFSR starting state) to reg5
LDR reg5 reg5
# load counter (starts at 64, added by 1 each time the loop increments, for storing)
IMM reg4 64
# load lfsr_patern to reg3
IMM reg3 62
# load mem[62] (lfsr_patern) to reg3
LDR reg3 reg3
# start padding loop
LOOP_BEGIN 1
# load space character into acc
IMM acc 0
# encode
XOR acc reg5
# store the encoded to mem
STR acc reg4
# update LFSR state
LFSR_UPDATE reg5 reg3
# update reg4 (mem address)
IMM acc 1
ADD reg4
# branching
LOOP A 1
# Finished encoding for preambles
# starting encode actual characters 
# loop times
IMM reg6 52
# address to read encoding characters
IMM reg2 0
LOOP_BEGIN 2
# load from mem[0~51]
LDR acc reg2
# encode
XOR acc reg5
# store the encoded to mem
STR acc reg4
# update LFSR state
LFSR_UPDATE reg5 reg3
# update reg4 (mem address)
IMM acc 1
ADD reg4
ADD reg2
# check if reached 128th byte
# IMM acc 128
# check if reached 128th byte
# SUB acc reg4
# if reached 128th byte
# B A 3
# otherwise
# branching
LOOP A 2
# load total cycles to reg6
IMM reg6 140
# load total - remaining cycles to reg6
SUB reg6 reg4
# Begin encoding characters after message
LOOP_BEGIN 3
# load space character into acc
IMM acc 0
# encode
XOR acc reg5
# store the encoded to mem
STR acc reg4
# update LFSR state
LFSR_UPDATE reg5 reg3
# update reg4 (mem address)
IMM acc 1
ADD reg4
# branching
LOOP A 3
EXIT